---
number: "34"
date: "2012-02-06T18:57:00+01:00"
title: "Praktyczne projektowanie oprogramowania"
speakers: "Paweł Lipiński"
lang: "pl"
sponsors: []
videoURL: ""
draft: false
---

Silne skupienie na projekcie oprogramowania było domeną "poprzedniej epoki" - UML w połączeniu ze wzorcami projektowymi miały rozwiązać problemy z niską jakością, niedeterministycznością i nieutrzymywalnością oprogramowania. Co zwykle jednak z tego wychodziło? Stosy papierów, długie godziny najwyżej płatnych pracowników technicznych poświęcone na klikaniu w narzędzia UML/Case oraz... często zupełnie niezgodny z tymi założeniami produkt. 

"Nowa szkoła" tworzenia oprogramowania - lekkie, zwinne i przyjemne metodyki przyniosły [YAGNI](https://en.wikipedia.org/wiki/You_ain%27t_gonna_need_it), [KISS](https://pl.wikipedia.org/wiki/KISS_%28regu%C5%82a%29) i odrzucenie [BDUF](https://en.wikipedia.org/wiki/Big_Design_Up_Front) często przez zarzucenie aktywności projektowania w ogóle, wierząc w quasi-magiczne wyłonienie się optymalnego designu ([ED](https://en.wikipedia.org/wiki/Emergent_Design)). Efektem miało być oprogramowanie, które nie jest [BBOM](https://en.wikipedia.org/wiki/Big_ball_of_mud), gdzie nie ma przypadków [DRY](https://pl.wikipedia.org/wiki/DRY) a wszystko osiągnięte jest przez permanentne skupienie na [SOLID](https://en.wikipedia.org/wiki/SOLID_%28object-oriented_design%29) i [GRASP](https://en.wikipedia.org/wiki/GRASP_%28object-oriented_design%29). Co jednak często wychodzi jeśli w ogóle nie spędzimy czasu na projektowaniu, tylko od razu siadamy do kodowania? Albo [FOD](https://en.wikipedia.org/wiki/Framework-oriented_design) (czyli silne związanie rdzenia systemu z wykorzystywaną technologią) albo trywialna i na długą metę nieutrzymywalna architektura serwisowa (czyli de facto design proceduralny), albo obiektowy groch z kapustą.

W czasie spotkania postaramy się wspólnie odnaleźć prawdziwie zwinne podejście do projektowania obiektowego. Będziemy projektować w paru zespołach jakąś złożoną dziedzinę z wykorzystaniem kart [CRC](https://en.wikipedia.org/wiki/Class-responsibility-collaboration_card) oraz zastanowimy się jak takie modelowanie połączyć z innymi zwinnymi praktykami - w szczegóności programowaniem w parach i TDD.
